\subsection{Mix Networks}

There are different kinds of mix networks. Here, only reencryption
mix-nets will be treated - first on a general level and then a certain
type of reencryption mix-net based on the El Gamal cryptosystem will
be described. In any mix-net used in the context of electronic
elections, the need of verification of correct execution is
essential. How this can be obtained is explored in the end of the
section.

\subsubsection{Overview}
http://www.rsa.com/rsalabs/staff/bios/ajuels/publications/universal/Universal.pdf

One purpose of mix networks is to provide untraceability
to its users. A mixnet may, for example, take as input a list of
encrypted messages of different origins. These messages pass through
the mixnet and is output decrypted and in a randomized order. This
property may be used to enable anonymous voting systems.

Different types of mixnets exist. There are decryption mixnets and
reencryption mixnets. This report treats the latter type. A
reencryption mixnet consists of a number of servers which sequentially
process the messages and reencrypts the list of messages and outputs
them in a randomized order. After passing through all servers, the
list of ciphertexts is decrypted and the result is a list of the
messages in random order. It should after decryption be infeasible to
deduce the position of each element in the initial list. This is
called \emph{untraceability}.

One use of mixnets is in the context of electronic voting systems. An
electronic election can be performed by the use of a reencryption
mixnet \\
(http://courses.csail.mit.edu/6.897/spring04/L17.pdf):
\begin{enumerate}
\item The mix servers prepare the mix-net by generating public and
  secret keys.
\item Each voter encrypts his vote and appends it to a public list of
  encrypted votes.
\item In sequential order each mix server takes as input the list of
  encrypted votes, reencrypts and outputs them in a randomized order,
  replacing the previous list of encrypted votes.
\item After all mix servers have processed the list, each vote is
  jointly decrypted and posted on a bulletin board making the outcome
  of the election universally available.
\end{enumerate}

Notice that the reencryption step is necessary before the actual
mixing as if it were omitted, the mixing would merely scramble the
list of original cryptotexts, providing no untraceability at all.

\subsubsection{El Gamal Mixnets}

Most reencryption networks use some variant of the El Gamal
Cryptosystem (http://courses.csail.mit.edu/6.897/spring04/L17.pdf),
since the homomorphic property of the El Gamal encryption allowes
reencryption.

A mixnet based on the El Gamal Cryptosystem consists of $k$ mixnet
servers mixing the votes of $n$ voters. Suppose the underlying group
is $G_q$ of prime order $q$ and with generator $g \in G_q$. The mixnet
works as follows \\
(http://courses.csail.mit.edu/6.897/spring04/L18.pdf)

\begin{enumerate}
\item A public key $pk = (g,y) = (g, g^x)$ is generated (infoga text om key distribution?)
\item Each voter $j$ encrypts his vote $m_j$ to create $c_{j,0} =
  \mathrm{Enc}_{pk}(m_j) = (g^{r_j},my^{r_j})$ for some random $r_j
  \in \mathbb{Z}_q$.  A list of all encrypted votes $c_0 = \left(
  c_{1,0}, \hdots c_{n,0}\right)$ is created.
\item For each mix server $i \in \{1,\hdots, k\}$, given the input
  $c_{i-1}$, a random permutation $\pi _i$ is chosen and a list 
  $$ 
  c_i =\left(\mathrm{ReEnc}_{pk}(c_{\pi_i(1),i-1}), \hdots,
  \mathrm{ReEnc}_{pk}(c_{\pi_i(n), i-1})\right) =
  $$
  is returned.
\item The final list $c_k$ is decrypted using the secret key $sk = x
  \in \mathbb{Z}_q$ (infoga text om key distribution?) to produce
  the output list
 $$ 
  (m_{\pi (1)}, \hdots , m_{\pi (n)}) =
  \left(\mathrm{Dec}_{sk}(c_{k,1}), \hdots, \mathrm{Dec}(c_{k,n})\right)
  $$
  
  for a permutation $\pi = \pi_k \circ \hdots \circ \pi_1$.
\end{enumerate}

The result of the election may now be computed while the origin of the
individual votes is unknown. Remark that all encryptions
$\mathrm{Enc}_{pk}$ are performed with some randomness $r \in
\mathbb{Z}_q$.

Note that this is a simplification, since if all parties were using
the same public key $pk$, this would imply that all parties also
possessed the same secret key (källa eller förklaring?). Consequently,
the mix-net, as stated above, does not provide untraceability.

In order to achieve untraceability, the mix-net servers need to
generate different public keys and still remain able to jointly
decrypt the output list of ciphertexts. The El Gamal cryptosystem
provides protocols for distributed key generation and decryption by
several parties (douglas doc). The details of these protocols will be
omitted, but the basic principle is the following.

A beforehand specified threshold number of mix-net servers
independently generate their own secret keys. The $l$th mix-net server
generates $sk_l = x \in \mathbb{Z}_Q$, from which a partial public key
$pk_l = (g,y_l) = (g,g^{x_l})$ can be derived. A joint public key is
then generated as $pk = \prod_l y_l$ and the corresponding secret key
$sk = \prod_l x_l$. After each server has processed the ciphertext
list, the list is jointly decrypted using a certain procedure. Omitted
in this description is the fact that the secret keys are actually
shared among all mix-net servers in such a way that no subset of the
servers smaller than the threshold number is able to [göra någonting
  dumt]. This protocol with a suitably chosen threshold values makes
it possible to correctly execute the mix-net even when the mix-net
contains dishonest parties (Källa på detta stycket, douglas doc?).

\subsubsection{Verification}
There are some problems related to electronic voting using
mixnets. One issue is that the mix servers may or may not execute
their part of the mixnet properly. For, example dishonest servers
could completely change the outcome of the election by replacing the
true votes with their own. A first solution may be to make sure that
every server is reliable. This is however difficult, as even an honest
party providing a computer acting as mix server may be affected by a
virus of some sort. Another and more feasible solution is to allow
verification by external parties.

The verification of execution relies on a concept called
zero-knowledge proof. A zero-knowledge proof is a cryptographic
protocol that can be used by one party, the prover, to prove to
another party that some statement is true. The greatest benefit of
using this protocol is that the prover can convince the other party of
the truthfulness of the statement without actually revealing any
additional information.

It is possible create a zero-knowledge proof based on the discrete
logarithm problem
(http://cs.nyu.edu/courses/spring07/G22.3220-001/lec3.pdf). In this
interactive scheme the prover is able to prove that he or she
possesses some secret discrete logarithm of an element in a group and
this will be done without actually revealing the secret. Only a
transcript of the scheme is generated. In fact, the scheme does not
reveal any additional information as any party is able to produce a
correct looking scheme on their own, which means that it reusing
(perhaps showing it someone else) an old transcript does not prove
knowledge of the secret.

When it comes to mix-nets, in order to ensure correct execution, one
can use zero-knowledge proofs to prove that every party shuffles their
input ciphertexts and reencrypts these ciphertexts. The shuffling part
may be proven to be correct by a zero-knowledge proof that proves that
a certain secret (encrypted) matrix is a permutation matrix. If the
list (vector) of ciphertexts is multiplied with this matrix a
permutation/shuffling has been performed.





