\section{Implementation of the Verifier}

\subsection{General Design Choices}

The first implementation choice was which programming language to use. We wanted to use well established technologies and have a good performance [REF] on the verifier. Considering these criteria and our programming skills, the choice was made between C, C++ and Java. Since other groups are working on implementations in Java we decided to use C or C++ and since we wanted to use features such as operator overloading and some OOP, we settled on C++.

We wanted to keep the verifier as close to the specification in layout as possible. Apart from some cryptographic primitives and the byte trees, there is almost no code repetition in the verifier. This meant that we would gain little to nothing by designing any kind of class structure or abstractions.

The byte trees were modelled with a few classes representing nodes and leaves. This enabled us to hide away complex operations behind simple interfaces which resulted in a more readable and maintainable code throughout the rest of the verifier.

\subsection{Third Party Libraries}

The verifier makes use of a few third party libraries. The actual arithmetic in the byte tree nodes are done with the GMP arithmetic library. This enables us to handle arbitrary large numbers which are used in cryptography. We also use RapidXML for parsing the protInfo.xml file at the very beginning of the verifier. For cryptographic hash functions we use OpenSSL and finally for unit testing we use Google's Google Test library.

\subsubsection{Arithmetic Library}

For the actual arithmetic done in the IntLeaf node class we use the GNU Multi-Precision Library (GMP). On windows this is replaced by the library Multiple Precision Integers and Rationals (MPIR), a drop in replacement which is easier to compile on windows systems. We chose GMP because it is a well known, very stable and free library for bignum operations.

\subsubsection{XML Parser}

RapidXML is used to parse the protInfo.xml file in the beginning of the algorithm. Since this is a very simple operation and we only do this once, we wanted something very lightweight to do the XML parsing. RapidXML only consists of a few header files and has a very easy to use interface. We chose it simply because it worked.

\subsubsection{Cryptographic Primitives}

All of the PRGs and ROs in the verifier are implemented in the verifier but at the core they all depend on cryptographic hash functions such as the SHA-2 family. We take these functions from the OpenSSL library. OpenSSL is a well known, stable and free library for various cryptographic related functions.

\subsubsection{Testing}



\subsection{Math Library}

Hur och varf√∂r har vi gjort som vi gjort?

\subsection{Pseudorandom Generators and Random Oracles}

\subsection{Verifier}

\subsection{Tests}

\subsection{Performance}

Viktigt?
